{"themeConfig":{"themeName":"notes","postPageSize":10,"archivesPageSize":50,"siteName":"王安琪的数据分析项目","siteDescription":"初级DA，请多多指教😆😆","footerInfo":"","showFeatureImage":true,"domain":"https://Angie-DA.github.io","postUrlFormat":"SHORT_ID","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":10,"archivesPath":"archives","postPath":"","tagPath":""},"posts":[{"content":"项目背景 以淘宝app平台为数据集，通过行业的指标对淘宝用户行为进行分析，从而探索淘宝用户的行为模式，具体指标包括：日PV和日UV分析，付费率分析，复购行为分析，漏斗流失分析和用户价值RFM分析。 数据介绍 列名称 说明 用户ID 整数类型，序列化后的用户ID 商品ID 整数类型，序列化后的商品ID 商品类目ID 整数类型，序列化后的商品所属类目ID 行为类型 字符串，枚举类型，包括('pv', 'buy', 'cart', 'fav') 时间戳 行为发生的时间戳 行为类型 说明 pv 商品详情页pv，等价于点击 buy 商品购买 cart 将商品加入购物车 fav 收藏商品 分析目标 1.用户行为分析/用户分类/漏斗分析； 2.用户流失分析/用户复购分析 1 数据读取 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import json from pyecharts.globals import CurrentConfig, NotebookType from pyecharts import options as opts from pyecharts.charts import Line from pyecharts.charts import * from pyecharts.globals import ThemeType from pyecharts.charts import Bar from pyecharts.charts import Funnel # 数据量过大超过1000w，分析时截取前100w行 columns=[&quot;userid&quot;, 'itemid', 'categoryid', 'type', 'timestamp'] data = pd.read_csv('E:/UserBehavior.csv', engine='python', encoding='utf-8', names=columns, chunksize=1000000, iterator=True) plt.rcParams['font.sans-serif'] = 'SimHei' dataframe = data.get_chunk(1000000) 1.1 查看数据的基本信息 dataframe.info() 2 数据清洗 dataframe.isnull().sum() 2.1 查看数据没有空值的数据的个数 dataframe.nunique() 2.2 查看数据的前n条 dataframe.head(n=11) 2.3 转换类型、截取数据、重新排列 # 删除重复值，结果一样数据无重复有效数据 dataframe.drop_duplicates(subset=['userid','itemid','type','timestamp'],keep='first',inplace=True) dataframe.nunique() # 删除重复值，结果一样数据无重复有效数据 dataframe.drop_duplicates(subset=['userid','itemid','type','timestamp'],keep='first',inplace=True) dataframe.nunique() # 将时间戳转为日期，从原数据的int64转化为日期类型 import datetime # to_datetime的默认时区不是中国需要改成北京时间+8h dataframe['time'] = pd.to_datetime(dataframe['timestamp'],unit='s')+datetime.timedelta(hours = 8) dataframe.head(n=5) dataframe.info() # 只截取2017.11.25-2017.12.3期间的数据 startTime = datetime.datetime.strptime(&quot;2017-11-25 00:00:00&quot;,&quot;%Y-%m-%d %H:%M:%S&quot;) endTime = datetime.datetime.strptime(&quot;2017-12-3 23:59:59&quot;,&quot;%Y-%m-%d %H:%M:%S&quot;) # print(type(startTime)) dataframe = dataframe[(dataframe.time&gt;=startTime)&amp;(dataframe.time&lt;=endTime)] # 删除原索引重新排列新的索引 dataframe = dataframe.reset_index(drop=True) # 拆分日期和小时 dataframe['date']=dataframe.time.dt.date dataframe['hour']=dataframe.time.dt.hour #删除原数据列的时间戳属性 dataframe.drop('timestamp',inplace=True, axis=1) dataframe.head() # 描述性统计数据，科学计数法表示 dataframe.describe() 2.4 数据清洗结果 print('数据清洗后共有{}行记录，{}列字段，字段分别为{}'.format(dataframe.shape[0],dataframe.shape[1],dataframe.columns.tolist())) 3 数据分析 # 有效时间内总用户数量，有操作的商品数量及类目 # 独立访客数UV total_unique_users = dataframe.userid.nunique() # 有操作的商品 total_unique_itemid = dataframe.itemid.nunique() # 有操作的商品类目 total_unique_categoryid = dataframe.categoryid.nunique() # 付费用户数 user_bought_count = dataframe[dataframe['type']=='buy'].userid.nunique() # 非付费用户数 user_nobought_count = total_unique_users - user_bought_count 3.1 输出当前数据各栏目计数 total={'UV':[total_unique_users],'商品数':[total_unique_itemid],'类目数':[total_unique_categoryid],'付费用户数':[user_bought_count],'非付费用户数':[user_nobought_count]} totalnew= pd.DataFrame(total,index = ['']) totalnew 3.2 用户复购率 用户复购率=购买2次及以上用户数/总购买用户数 groupby_userid = dataframe.groupby('userid') user_type = groupby_userid.type.value_counts().unstack() # 使用unstack进行不堆叠操作，列方向上的索引转成行方向的索引 user_type.tail() 3.3 可视化图表 # 提取数据 type_series = dataframe.type.value_counts() # 提取数据 type_series = dataframe.type.value_counts() 3.3.1 饼图-用户行为占比 plt.figure(figsize = (5,5), dpi = 100) plt.pie(type_series, labels=type_series.index, autopct='%1.2f%%', pctdistance = 0.8, counterclock = False, wedgeprops = {'width':0.4}) plt.title('用户行为占比') plt.show() # plt.savefig('./用户行为占比.png') 3.3.2 动态曲线-每日pv、uv #提取数据 pv_day = dataframe[dataframe.type =='pv'].groupby('date')['type'].count() uv_day = dataframe[dataframe.type =='pv'].drop_duplicates(['userid','date']).groupby('date')['userid'].count() #转换成图表所需的格式 #1、日期（list.index） date = pv_day.index #2、pv、uv（list.values） pv = np.around(pv_day.values/10000,decimals=2) # uv = np.around(uv_day.values,decimals=2) uv=uv_day # 制作曲线图表 x=list(date) y1=pv y2=uv pvuv_day_line = (Line(init_opts=opts.InitOpts(theme=ThemeType.DARK)) .add_xaxis(x) #x轴数据源 .add_yaxis('pv',#图例名字 y1, #y1轴数据源 label_opts=opts.LabelOpts(is_show=False), #不显示数据标签 ) .add_yaxis('uv',#图例名字 yaxis_index=1, #Y的双轴1号索引（区别于y1轴） y_axis=y2, #y2轴数据源 label_opts=opts.LabelOpts(is_show=False) #不显示数据标签 ) .extend_axis( #y2轴设置 yaxis=opts.AxisOpts( name='uv',#轴名字 min_=5000,#轴起点值 max_=15000, #轴最大值 interval=1000, #轴区间间隔 axislabel_opts=opts.LabelOpts(formatter=&quot;{value} 人&quot;) #轴数据标签格式设置 ) ) .set_global_opts( #全局设置 tooltip_opts=opts.TooltipOpts(is_show=True,trigger=&quot;axis&quot;,axis_pointer_type='cross'), #随鼠标位置显示xy轴的数据、聚焦形式(交叉) xaxis_opts=opts.AxisOpts(type_='category',axispointer_opts=opts.AxisPointerOpts(is_show=True,type_=&quot;shadow&quot;)),#随鼠标位置凸显x轴长条、凸显形式（阴影） yaxis_opts=opts.AxisOpts(name='pv',axislabel_opts=opts.LabelOpts(formatter=&quot;{value} 万次&quot;)),#y1轴(默认轴)名字、轴数据标签格式设置 title_opts=opts.TitleOpts(title=&quot;每日pv和uv&quot;) #标题 ) ) pvuv_day_line.render_notebook() #展示图表 3.3.3 漏斗图-用户行为 第一层：用户全部行为（pv、buy、cart、fav） 第二层：收藏/加购行为（cart/fav） 第三层：付费行为（buy） 第一层：用户全部行为，同上 第二层：仅浏览就付费行为（buy） 目的：分析用户行为的转化率 用户各行为数据计算方式 # 有效日期9天内各个行为的操作总数，每日平均操作数，每日平均操作用户数记录 type_df=pd.DataFrame([type_series,type_series/9,type_series/total_unique_users], index=['total','avg_day','avg_user']) # 付费用户行为记录 type_df.loc['paying_user']=dataframe[dataframe['userid'].isin(dataframe[dataframe['type']=='buy']['userid'])].type.value_counts() type_df # 有效日期9天内各个行为的操作总数，每日平均操作数，每日平均操作用户数记录 type_df=pd.DataFrame([type_series,type_series/9,type_series/total_unique_users], index=['total','avg_day','avg_user']) ​ # 付费用户行为记录 type_df.loc['paying_user']=dataframe[dataframe['userid'].isin(dataframe[dataframe['type']=='buy']['userid'])].type.value_counts() type_df # 提取type用户行为列中的每一个行为数据 pv_df = dataframe[dataframe['type']=='pv'] buy_df = dataframe[dataframe['type']=='buy'] cart_df = dataframe[dataframe['type']=='cart'] fav_df = dataframe[dataframe['type']=='fav'] # 方式1 点击-&gt;加购-&gt;购买 pv_cart_df = pd.merge(left=pv_df,right=cart_df,how='inner',on=['userid','itemid','categoryid'],suffixes=('_pv','_cart')) cart_buy_df = pd.merge(left=cart_df,right=buy_df,how='inner',on=['userid','itemid','categoryid'],suffixes=('_cart','_buy')) count_users_pv_cart = pv_cart_df[pv_cart_df.time_pv &lt; pv_cart_df.time_cart].userid.nunique() count_users_cart_buy = cart_buy_df[cart_buy_df.time_cart &lt; cart_buy_df.time_buy].userid.nunique() # 方式2 点击-&gt;收藏-&gt;购买 pv_fav_df = pd.merge(left=pv_df,right=fav_df,how='inner',on=['userid','itemid','categoryid'],suffixes=('_pv','_fav')) fav_buy_df = pd.merge(left=fav_df,right=buy_df,how='inner',on=['userid','itemid','categoryid'],suffixes=('_fav','_buy')) count_user_pv_fav = pv_fav_df[pv_fav_df.time_pv &lt; pv_fav_df.time_fav].userid.nunique() count_user_fav_buy = fav_buy_df[fav_buy_df.time_fav &lt; fav_buy_df.time_buy].userid.nunique() # 方式3 点击-&gt;购买 pv_beh_buy_df = pd.merge(left=pv_df,right=buy_df,how='inner',on=['userid','itemid','categoryid'],suffixes=('_pv','_buy')) count_user_pv_beh_buy = pv_beh_buy_df[pv_beh_buy_df.time_pv &lt; pv_beh_buy_df.time_buy].userid.nunique() count_user_pv_buy = count_user_pv_beh_buy - count_users_cart_buy - count_user_fav_buy print(count_users_cart_buy) print(count_user_fav_buy) print(count_user_pv_buy) fav_cart_ratio = (count_user_pv_fav+count_users_pv_cart)/total_unique_users buy_beh_ratio=(count_user_fav_buy+count_users_cart_buy)/total_unique_users buy_ratio = count_user_pv_buy /total_unique_users # fav_buy=count_users_cart_buy/count_users_pv_cart # cart_buy=count_user_fav_buy/count_user_pv_fav print('收藏加购用户转化率为:%.2f%%'%(fav_cart_ratio*100)) print('收藏加购-&gt;购买用户转化率为:%.2f%%'%(buy_beh_ratio*100)) print('浏览直接购买用户转化率为:%.2f%%'%(buy_ratio*100)) from pyecharts.charts import Funnel # 漏斗图datapair process_data_pair = [(&quot;点击量&quot;, total_unique_users), (&quot;收藏加购量&quot;, count_user_pv_fav+count_users_pv_cart), (&quot;购买量&quot;, count_user_fav_buy+count_users_cart_buy)] ( Funnel(init_opts=opts.InitOpts(width='500px', height='400px')) .add(&quot;type&quot;, data_pair=process_data_pair, label_opts=opts.LabelOpts(position=&quot;top&quot;), gap=2, tooltip_opts=opts.TooltipOpts(is_show=True)) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;用户转化率&quot;, subtitle=&quot;process 浏览-&gt;收藏/加购-&gt;购买&quot;)) ).render_notebook() process_data_pair = [(&quot;点击量&quot;, total_unique_users), (&quot;购买量&quot;, count_user_pv_buy)] ( Funnel(init_opts=opts.InitOpts(width='500px', height='400px')) .add(&quot;type&quot;, data_pair=process_data_pair, label_opts=opts.LabelOpts(position=&quot;top&quot;), gap=2, tooltip_opts=opts.TooltipOpts(is_show=True)) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;用户转化率&quot;, subtitle=&quot;process 浏览-&gt;购买&quot;)) ).render_notebook() 3.3.4 柱状图-用户复购率 repurchase_users = user_type[user_type['buy']&gt;=2].shape[0] # 购买记录超过1次的用户数 repurchase_rate = repurchase_users/user_bought_count print(&quot;复购率:{:.2f}%&quot;.format(repurchase_rate*100)) ​ # 进一步分析复购次数 sns.histplot(user_type[user_type['buy']&gt;=2]['buy']-1,kde=False) plt.show() 结论：淘宝用户复购率达到66.01%，但是进一步查看用户复购次数，发现绝大多数用户复购次数很少； 个人思考：在淘宝下沉扩展获取新用户的同时，促进老用户复购次数增加，进一步稳定提高复购率应是更重要的。 3.3.5 动态柱状-用户量变化趋势 每日的活跃用户量基本在71%左右，而成交客户基本维持在20% behavior_types=list(dict(dataframe['type'].value_counts()).keys()) behavior_types groupby_date = dataframe.groupby(by=dataframe.date) # 根据日期分组 dates = sorted(list(dict(dataframe['date'].value_counts()).keys())) dates_df = pd.DataFrame(data=None, index=dates, columns=behavior_types) # 创建按日期分组的数据框 for d in dates: dates_df.loc[d] = groupby_date.get_group(d).type.value_counts() # 按日期填充数据框 # 日期转换为星期，datetime.datetime.isoweekday（）返回的1-7代表周一--周日 dates_df['weekday'] = [datetime.datetime.isoweekday(datetime.date(x.year,x.month,x.day)) for x in dates_df.index] dates_df dates_df['uv'] = [groupby_date.get_group(d).userid.nunique() for d in dates] # 每日独立访客量 # 自定义当天使用淘宝app进行5次操作（任何行为）的用户就是活跃用户 active_user_standard = 3 # 自定义活跃用户操作次数 dates_df['dau'] = [(groupby_date.get_group(d).groupby(by='userid').size()&gt;active_user_standard).value_counts()[True] for d in dates] dates_df['au_rate'] = dates_df['dau']/dates_df['uv'] # 活跃用户比例 dates_df['buyer'] = dataframe[dataframe['type']=='buy'].groupby(by=['date','userid']).size().count(level=0) dates_df['buyer_rate'] = dates_df['buyer']/dates_df['uv'] # 付费用户比例 dates_df['ARPU'] = dates_df['buy']/dates_df['uv'] # 人均购买量=总交易量/当日UV dates_df['ARPPU'] = dates_df['buy']/dates_df['buyer'] # 付费用户人均购买量 dates_df ( Line(init_opts=opts.InitOpts(width=&quot;800px&quot;, height=&quot;500px&quot;)) .add_xaxis(xaxis_data=dates_df.index) .add_yaxis(&quot;uv&quot;, y_axis=dates_df['uv'],is_symbol_show=False) .add_yaxis(&quot;dau&quot;,y_axis=dates_df['dau'],is_symbol_show=False) .add_yaxis(&quot;buyer&quot;,y_axis=dates_df['buyer'],is_symbol_show=False) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;用户量变化趋势&quot;, subtitle=&quot;2017/11/25-2017/12/03期间用户量变化趋势&quot;), tooltip_opts=opts.TooltipOpts(trigger='axis'), toolbox_opts=opts.ToolboxOpts(is_show=True), xaxis_opts=opts.AxisOpts(type_='category', boundary_gap=False)) ).render_notebook() 3.3.6 用户价值分析——RFM分析（Recency，Frequency，Monetary）¶ RFM模型通过一个客户的近期购买行为、购买的总体频率以及花了多少钱3项指标来描述该客户的价值状况。 R（Recency）：客户最近一次交易时间的间隔。 F（Frequency）：客户在最近一段时间内交易的次数。 M（Monetary）：客户在最近一段时间内交易的金额。 本次分析数据集不含金额，仅从R、F两个维度进行分析 groupby_buy_userid = dataframe[dataframe['type']=='buy'].groupby(by='userid') RF = pd.DataFrame(index=groupby_buy_userid.groups.keys(), columns=['R', 'F']) RF['F'] = groupby_buy_userid.type.count() RF['last_buy_time'] = groupby_buy_userid.time.max() # 假设获取数据集的第二天进行分析，所以选择2017/12/04为对照日期，保留天数 RF['R'] = (pd.to_datetime('2017-12-04')-RF['last_buy_time']).dt.days # 最近的一次交易记录距离2017/12/04为0天 # 即12/03购买相差还不到一天，最远的为9天，平均为2.53天 # R划分4个区域 0-1,2-3,4-6,7-9,分别得分4，3，2，1 # 交易次数最少为1次最多为93次,平均3次 # 这里的3次分母是所有购买过商品的用户 # 而之前得出的人均购买次数2次分母是所有用户 # F划分4个区域 1,2,3,4+，分别得分1，2，3，4 RF[['R','F']].describe() def R_score(x): if 0 &lt;= x &lt;= 1: return 4 elif 2 &lt;= x &lt;= 3: return 3 elif 4 &lt;= x &lt;= 6: return 2 elif 7 &lt;= x &lt;= 9: return 1 else: return 0 def F_score(x): if x == 1: return 1 elif x == 2: return 2 elif x == 3: return 3 elif x &gt;= 4: return 4 else: return 0 # 根据R,F进行评分 RF['R_score'] = RF.R.map(R_score) RF['F_score'] = RF.F.map(F_score) RF['R&gt;mean?']=(RF['R_score']&gt;RF['R_score'].mean())*1 RF['F&gt;mean?']=(RF['F_score']&gt;RF['F_score'].mean())*1 def user_classfication(tup): R_score, F_score = tup if R_score == 0 and F_score == 1: return &quot;重要保持客户&quot; elif R_score == 1 and F_score == 0: return &quot;重要发展客户&quot; elif R_score == 1 and F_score == 1: return &quot;重要价值客户&quot; elif R_score == 0 and F_score == 0: return &quot;重要挽留客户&quot; else: return None RF['user_classification'] = RF[['R&gt;mean?','F&gt;mean?']].apply(user_classfication, axis=1) RF.head() 统计用户分类情况 RF.user_classification.value_counts() 用户分类占比 RF.user_classification.value_counts(1) 个人思考：根据RFM模型对用户分类后发现重要挽留客户比例最高，其次是重要价值用户，淘宝仅需要适当营销并推出一系列的活动就能稳固部分重要挽留客户，同时，需要提高社群管理的效率，将重要保持客户和重要发展客户转变为重要价值客户，可采取定期发送文案、赠送优惠券等方式。 ","tags":[],"title":"Python基于淘宝用户行为分析","feature":"","link":"https://Angie-DA.github.io/sCLVmTSym/","stats":{"text":"15 min read","time":885000,"words":3166,"minutes":15},"date":"2022-03-13 19:21:55","dateFormat":"2022-03-13"}]}